use std::{any::Any, cell::Cell, fmt, ptr::NonNull};

use late_struct::{LateInstance, late_field, late_struct};

use crate::{KeepAliveManager, ObjectArena, RawHandle};

// === World === //

thread_local! {
    static WORLD_TLS: Cell<Option<NonNull<World>>> = const { Cell::new(None) };
}

/// An alias to [`&mut World`](World).
pub type W<'a> = &'a mut World;

/// An alias to [`&World`](World).
pub type Wr<'a> = &'a World;

/// A context in which [`Object`](crate::Object)s are allocated.
///
/// Objects allocated in one world cannot be accessed by another.
#[derive(Default)]
pub struct World {
    inner: LateInstance<world_ns::WorldNs>,
}

pub(crate) mod world_ns {
    #[non_exhaustive]
    #[expect(missing_docs)] // (never exposed in the public API)
    pub struct WorldNs;
}

late_struct!(world_ns::WorldNs => dyn Any);

impl fmt::Debug for World {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("World").finish_non_exhaustive()
    }
}

impl World {
    /// Creates a new `World`.
    ///
    /// Alias to [`World::default()`].
    pub fn new() -> Self {
        Self::default()
    }

    /// Alias to [`WorldDebug::new`].
    pub fn debug<T>(&self, value: T) -> WorldDebug<'_, T> {
        WorldDebug::new(value, self)
    }

    /// Applies all enqueued `Object` deletions generated by dropping all [`Strong`](crate::Strong)
    /// references to a given object. Deletions will not be applied unless this method is called.
    pub fn flush(&mut self) {
        while let Some((_, condemned)) = self.manager_mut().take_condemned() {
            (condemned.destructor)(condemned.handle, self);
        }
    }

    /// Calls `f` while passing an immutable reference to the `World` through thread-local storage
    /// for the duration of the call. This reference can later be fetched using [`World::fetch_tls`].
    ///
    /// The [`fmt::Debug`] implementation for [`Handle`](crate::Handle)s makes use of this reference
    /// to provide pretty-printing for its pointee. In those cases, however, you should likely use
    /// [`Handle::debug`](crate::Handle::debug) to obtain a [`WorldDebug`] wrapper whose
    /// `fmt::Debug` implementation calls `provide_tls` on your behalf.
    pub fn provide_tls<R>(&self, f: impl FnOnce() -> R) -> R {
        let _guard = scopeguard::guard(WORLD_TLS.replace(Some(NonNull::from(self))), |old| {
            WORLD_TLS.set(old);
        });

        f()
    }

    /// Obtains a reference to a `World` provided by an earlier call to [`World::provide_tls`],
    /// passing in `None` if no such call has previously been made.
    pub fn fetch_tls<R>(f: impl FnOnce(Option<&World>) -> R) -> R {
        f(WORLD_TLS.get().map(|v| unsafe { v.as_ref() }))
    }

    /// Obtains an immutable reference to an [`ObjectArena`] by its type.
    ///
    /// <div class="warning">
    /// This is likely only relevant to you if you are <a href="index.html#custom-arenas">implementing a
    /// custom arena</a>.
    /// </div>
    pub fn arena<T: ObjectArena>(&self) -> &T {
        self.inner.get::<T::Object>()
    }

    /// Obtains a mutable reference to an [`ObjectArena`] by its type.
    ///
    /// <div class="warning">
    /// This is likely only relevant to you if you are <a href="index.html#custom-arenas">implementing a
    /// custom arena</a>.
    /// </div>
    pub fn arena_mut<T: ObjectArena>(&mut self) -> &mut T {
        self.inner.get_mut::<T::Object>()
    }

    /// Obtains an immutable reference to the world's [`WorldKeepAliveManager`].
    ///
    /// <div class="warning">
    /// This is likely only relevant to you if you are <a href="index.html#custom-arenas">implementing a
    /// custom arena</a>.
    /// </div>
    pub fn manager(&self) -> &WorldKeepAliveManager {
        self.inner.get::<WorldKeepAliveManager>()
    }

    /// Obtains a mutable reference to the world's [`WorldKeepAliveManager`].
    ///
    /// <div class="warning">
    /// This is likely only relevant to you if you are <a href="index.html#custom-arenas">implementing a
    /// custom arena</a>.
    /// </div>
    pub fn manager_mut(&mut self) -> &mut WorldKeepAliveManager {
        self.inner.get_mut::<WorldKeepAliveManager>()
    }

    /// Obtains a mutable reference to an [`ObjectArena`] by its type alongside the world's
    /// [`WorldKeepAliveManager`].
    ///
    /// <div class="warning">
    /// This is likely only relevant to you if you are <a href="index.html#custom-arenas">implementing a
    /// custom arena</a>.
    /// </div>
    pub fn arena_and_manager_mut<T: ObjectArena>(
        &mut self,
    ) -> (&mut T, &mut WorldKeepAliveManager) {
        self.inner.get_two::<T::Object, WorldKeepAliveManager>()
    }
}

// === WorldDebug === //

/// A wrapper around `T` whose [`fmt::Debug`] implementation provides the [`World`] via thread-local
/// storage.
///
/// Specifically, `WorldDebug`'s `fmt::Debug` implementation wraps its call to `T`'s `fmt::Debug`
/// in [`World::provide_tls`].
///
/// This is useful when used in conjunction with a [`Handle`](crate::Handle) since `Handle`'s
/// `fmt::Debug` implementation can make use of the `World` to pretty-print its pointee. In those
/// cases, you should use [`Handle::debug`](crate::Handle::debug) to obtain a `WorldDebug` wrapper
/// around the handle in an ergonomic fashion.
// Not `#[must_use]` because these are often printed using `dbg!()`.
#[derive(Copy, Clone)]
pub struct WorldDebug<'a, T> {
    world: &'a World,
    value: T,
}

impl<'a, T> WorldDebug<'a, T> {
    /// Wraps the `value` in a `WorldDebug` which also borrows the supplied [`World`].
    pub fn new(value: T, w: Wr<'a>) -> Self {
        Self { value, world: w }
    }
}

impl<T: fmt::Debug> fmt::Debug for WorldDebug<'_, T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.world.provide_tls(|| self.value.fmt(f))
    }
}

// === KeepAlive === //

/// The type of the [`KeepAliveManager`] managed by a [`World`].
pub type WorldKeepAliveManager = KeepAliveManager<WorldKeepAliveUserdata>;

late_field!(WorldKeepAliveManager[world_ns::WorldNs]);

/// Userdata for the [`KeepAliveManager`] managed by [`World`].
///
/// <div class="warning">
/// This is likely only relevant to you if you are <a href="index.html#custom-arenas">implementing a
/// custom arena</a>.
/// </div>
#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]
pub struct WorldKeepAliveUserdata {
    /// The function pointer called by [`World::flush`] when it deletes this slot.
    pub destructor: fn(handle: RawHandle, w: W),

    /// The handle with which the `destructor` should be called.
    pub handle: RawHandle,
}
